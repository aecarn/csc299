 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a//dev/null b/maze_game.py
index 0000000000000000000000000000000000000000..38d861a5e981042a45419e83e809cb8c929c8a4e 100644
--- a//dev/null
+++ b/maze_game.py
@@ -0,0 +1,300 @@
+"""Terminal maze exploration game.
+
+Run this module directly to generate a brand new maze and explore it from
+within the terminal.  Use the W/A/S/D keys (or the arrow-key words) to move
+around, request hints, or ask the program to solve the maze for you.
+"""
+from __future__ import annotations
+
+import random
+import sys
+from collections import deque
+from dataclasses import dataclass
+from typing import List, Optional, Sequence, Tuple
+
+
+Coordinate = Tuple[int, int]
+
+
+def _ensure_odd(value: int, minimum: int = 5) -> int:
+    """Return an odd integer that is at least ``minimum``."""
+
+    if value < minimum:
+        value = minimum
+    if value % 2 == 0:
+        value += 1
+    return value
+
+
+class Maze:
+    """Randomly generated perfect maze using depth-first search backtracking."""
+
+    WALL = "#"
+    SPACE = " "
+
+    def __init__(self, width: int = 21, height: int = 21, seed: Optional[int] = None):
+        self.width = _ensure_odd(width)
+        self.height = _ensure_odd(height)
+        self._rng = random.Random(seed)
+        self.grid: List[List[str]] = [[self.WALL for _ in range(self.width)] for _ in range(self.height)]
+        self.start: Coordinate = (1, 1)
+        self.goal: Coordinate = (self.height - 2, self.width - 2)
+        self._generate()
+
+    def _generate(self) -> None:
+        """Carve a perfect maze via randomized depth-first search."""
+
+        stack = [self.start]
+        self.grid[self.start[0]][self.start[1]] = self.SPACE
+
+        def neighbors(cell: Coordinate) -> Sequence[Tuple[Coordinate, Coordinate]]:
+            r, c = cell
+            candidates = []
+            for dr, dc in ((-2, 0), (2, 0), (0, -2), (0, 2)):
+                nr, nc = r + dr, c + dc
+                between = (r + dr // 2, c + dc // 2)
+                if 1 <= nr < self.height - 1 and 1 <= nc < self.width - 1:
+                    candidates.append(((nr, nc), between))
+            self._rng.shuffle(candidates)
+            return candidates
+
+        while stack:
+            current = stack[-1]
+            for (nr, nc), between in neighbors(current):
+                if self.grid[nr][nc] == self.WALL:
+                    # Carve the path to the neighbor and continue the walk.
+                    self.grid[between[0]][between[1]] = self.SPACE
+                    self.grid[nr][nc] = self.SPACE
+                    stack.append((nr, nc))
+                    break
+            else:
+                stack.pop()
+
+        # Ensure the exit is open even if the DFS never carved there.
+        gr, gc = self.goal
+        self.grid[gr][gc] = self.SPACE
+
+    def is_open(self, row: int, column: int) -> bool:
+        return self.grid[row][column] == self.SPACE
+
+    def to_lines(self) -> List[str]:
+        return ["".join(row) for row in self.grid]
+
+
+@dataclass
+class MoveResult:
+    moved: bool
+    message: Optional[str] = None
+
+
+class MazeGame:
+    """Interactive maze navigation game."""
+
+    MOVE_MAP = {
+        "w": (-1, 0),
+        "up": (-1, 0),
+        "k": (-1, 0),  # Vim key bindings
+        "s": (1, 0),
+        "down": (1, 0),
+        "j": (1, 0),
+        "a": (0, -1),
+        "left": (0, -1),
+        "h": (0, -1),
+        "d": (0, 1),
+        "right": (0, 1),
+        "l": (0, 1),
+    }
+
+    def __init__(self, width: int = 21, height: int = 21, seed: Optional[int] = None):
+        self.maze = Maze(width, height, seed=seed)
+        self.player: Coordinate = self.maze.start
+        self.visited: set[Coordinate] = {self.player}
+        self.moves_taken = 0
+
+    def render(self) -> str:
+        display = [row[:] for row in self.maze.grid]
+        start = self.maze.start
+        goal = self.maze.goal
+
+        for row, col in self.visited:
+            if (row, col) not in (start, goal, self.player):
+                display[row][col] = "."
+
+        sr, sc = start
+        gr, gc = goal
+        display[sr][sc] = "S"
+        display[gr][gc] = "G"
+        pr, pc = self.player
+        display[pr][pc] = "P"
+
+        horizontal_border = "+" + "-" * self.maze.width + "+"
+        rows = [horizontal_border]
+        for row in display:
+            rows.append("|" + "".join(row) + "|")
+        rows.append(horizontal_border)
+        return "\n".join(rows)
+
+    def move(self, delta: Tuple[int, int]) -> MoveResult:
+        r, c = self.player
+        dr, dc = delta
+        nr, nc = r + dr, c + dc
+        if not (0 <= nr < self.maze.height and 0 <= nc < self.maze.width):
+            return MoveResult(False, "You bump into the edge of the world.")
+        if not self.maze.is_open(nr, nc):
+            return MoveResult(False, "A wall blocks your way.")
+        self.player = (nr, nc)
+        self.visited.add(self.player)
+        self.moves_taken += 1
+        return MoveResult(True)
+
+    def reached_goal(self) -> bool:
+        return self.player == self.maze.goal
+
+    def shortest_path(self, origin: Optional[Coordinate] = None) -> Optional[List[Coordinate]]:
+        start = origin or self.player
+        goal = self.maze.goal
+        queue: deque[Coordinate] = deque([start])
+        parent: dict[Coordinate, Optional[Coordinate]] = {start: None}
+
+        while queue:
+            current = queue.popleft()
+            if current == goal:
+                break
+            r, c = current
+            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
+                nr, nc = r + dr, c + dc
+                if not (0 <= nr < self.maze.height and 0 <= nc < self.maze.width):
+                    continue
+                if not self.maze.is_open(nr, nc):
+                    continue
+                neighbor = (nr, nc)
+                if neighbor in parent:
+                    continue
+                parent[neighbor] = current
+                queue.append(neighbor)
+        else:
+            return None
+
+        # Reconstruct path
+        path: List[Coordinate] = []
+        node: Optional[Coordinate] = goal
+        while node is not None:
+            path.append(node)
+            node = parent.get(node)
+        path.reverse()
+        return path
+
+    def describe_path(self, path: Sequence[Coordinate]) -> str:
+        arrows = []
+        for (r1, c1), (r2, c2) in zip(path, path[1:]):
+            dr = r2 - r1
+            dc = c2 - c1
+            if dr == -1:
+                arrows.append("↑")
+            elif dr == 1:
+                arrows.append("↓")
+            elif dc == -1:
+                arrows.append("←")
+            elif dc == 1:
+                arrows.append("→")
+        return " ".join(arrows)
+
+    def play(self) -> None:
+        print(self.render())
+        print(self._instructions())
+        while True:
+            if self.reached_goal():
+                print(f"Congratulations! You escaped the maze in {self.moves_taken} moves!")
+                return
+            command = input("Move (W/A/S/D, 'help', 'hint', 'solve', 'quit'): ").strip().lower()
+            if not command:
+                continue
+            if command in {"quit", "exit", "q"}:
+                print("Thanks for playing!")
+                return
+            if command in {"help", "?"}:
+                print(self._instructions())
+                continue
+            if command == "hint":
+                path = self.shortest_path()
+                if path and len(path) > 1:
+                    next_step = path[1]
+                    dr = next_step[0] - self.player[0]
+                    dc = next_step[1] - self.player[1]
+                    hint = {
+                        (-1, 0): "up",
+                        (1, 0): "down",
+                        (0, -1): "left",
+                        (0, 1): "right",
+                    }[(dr, dc)]
+                    print(f"Try moving {hint} next.")
+                else:
+                    print("No hint available; maybe you're already at the goal?")
+                continue
+            if command == "solve":
+                path = self.shortest_path()
+                if not path:
+                    print("I couldn't find a way out!")
+                else:
+                    print("Shortest path:", self.describe_path(path))
+                continue
+
+            if command in self.MOVE_MAP:
+                result = self.move(self.MOVE_MAP[command])
+                if result.message:
+                    print(result.message)
+                print(self.render())
+                continue
+
+            print("Unknown command. Type 'help' for assistance.")
+
+    def _instructions(self) -> str:
+        return (
+            "Navigate the maze using W/A/S/D, the arrow-key words (up/left/etc.), "
+            "or Vim-style H/J/K/L commands.\n"
+            "Visit every corner to reveal more of the layout. Ask for a 'hint' "
+            "to learn which direction to move next or 'solve' to display the "
+            "shortest path from your current position.\n"
+            "Reach the tile marked 'G' to win."
+        )
+
+
+def _prompt_dimension(name: str, default: int) -> int:
+    while True:
+        response = input(f"Choose {name} (odd number >= 5) [{default}]: ").strip()
+        if not response:
+            return default
+        try:
+            value = int(response)
+        except ValueError:
+            print("Please enter a whole number.")
+            continue
+        value = _ensure_odd(value)
+        if value < 5:
+            print("The maze must be at least 5 cells in size.")
+            continue
+        return value
+
+
+def main(argv: Optional[Sequence[str]] = None) -> int:
+    argv = list(argv or sys.argv[1:])
+    seed: Optional[int] = None
+    if argv:
+        try:
+            seed = int(argv[0])
+        except ValueError:
+            print("First argument must be an integer seed.")
+            return 2
+        print(f"Using seed {seed} for reproducible maze generation.")
+
+    print("Welcome to the maze builder! Press Enter to accept the default dimensions.")
+    width = _prompt_dimension("width", 21)
+    height = _prompt_dimension("height", 21)
+
+    game = MazeGame(width=width, height=height, seed=seed)
+    game.play()
+    return 0
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
 
EOF
)
